<!DOCTYPE html>
<html lang="en">
<head>
    <title>Oct 7 locations</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <link rel="icon" href="https://github.com/yuval-harpaz/alarms/blob/master/docs/logo.png?raw=true" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
    #map{
        height: 100vh;
        width: 100vw;
    }
    #popup-message {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 12px 18px;
      border-radius: 8px;
      font-size: 1.2em;
      font-weight: 500;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      direction: ltr;
      text-align: center;
      max-width: 400px;
      border: 2px solid #007bff;
    }

    #popup-message .close-btn {
      position: absolute;
      top: 5px;
      right: 8px;
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      color: #666;
      line-height: 1;
    }

    #popup-message .close-btn:hover {
      color: #000;
    }

    #popup-message a {
      display: inline;
      font-size: 0.8em;
      color: #007bff;
      text-decoration: none;
    }
    
    #popup-message p {
      font-size: 0.7em;
      color: #333;
      margin: 8px 0;
      line-height: 1.3;
    }
    
    #popup-message a:hover {
      text-decoration: underline;
    }
    
    #search-box {
      position: absolute;
      top: 60px;
      left: 10px;
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      z-index: 1000;
      width: 250px;
    }
    
    #search-input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      direction: ltr;
      box-sizing: border-box;
    }
    
    #search-results {
      max-height: 300px;
      overflow-y: auto;
      margin-top: 5px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      display: none;
    }
    
    .search-result-item {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
      direction: ltr;
      text-align: left;
    }
    
    .search-result-item:hover {
      background: #f0f0f0;
    }
    
    .search-result-item:last-child {
      border-bottom: none;
    }
    .leaflet-tooltip-left:before {
        right: 0;
        margin-right: -12px;
        border-left-color: transparent;
    }
    .leaflet-tooltip-right:before {
        left: 0;
        margin-left: -12px;
        border-right-color: transparent;
    }
    .red-tooltip {
        background: transparent;
        box-shadow: none;
        border: transparent;
        color: red;
        font-weight: bold;
        font-size: 18px;
        line-height: 16px;
    }
    .blue-tooltip {
        background: transparent;
        box-shadow: none;
        border: transparent;
        color: blue;
        font-weight: bold;
        font-size: 18px;
        line-height: 16px;
        text-align: left;
    }
    </style>
</head>
<body>
    <div id="popup-message">
      <button class="close-btn" onclick="document.getElementById('popup-message').style.display='none'">&times;</button>
      Map of October 7th Event Locations<br>
      <p>
      The map includes locations of murders, kidnappings, and combat casualties of October 7th victims.<br>
      More details at 
      </p><a href="https://oct7database.com/locations_intro_en.html" target="_blank">oct7database.com</a>
    </div>
    
    <div id="search-box">
      <input type="text" id="search-input" placeholder="Search by name or location...">
      <div id="search-results"></div>
    </div>
    <div id="map">
        <script type="module">
            // First load the database to get English names
            var nameMap = {}; // pid -> {firstName, lastName}
            
            Papa.parse("https://raw.githubusercontent.com/yuval-harpaz/alarms/refs/heads/master/data/oct7database.csv", {
                download: true,
                header: true,
                complete: function(results) {
                    // Build name map from pid to English names
                    results.data.forEach(function(row) {
                        if (row.pid && row['first name'] && row['last name']) {
                            nameMap[row.pid] = {
                                firstName: row['first name'],
                                lastName: row['last name'],
                                eventLocation: row['Event location'] || ''
                            };
                        }
                    });
                    
                    // Now load the map
                    loadMap();
                }
            });
            
            function loadMap() {
            const iconSize = 16;
            const redIcon = L.icon({
                iconUrl: 'https://yuval-harpaz.github.io/alarms/red_ring.png',
                iconSize: [iconSize, iconSize],
                iconAnchor: [iconSize / 2, iconSize / 2],
                popupAnchor: [0, 0]
            });
            const blueIcon = L.icon({
                iconUrl: 'https://yuval-harpaz.github.io/alarms/blue_square.png',
                iconSize: [iconSize, iconSize],
                iconAnchor: [iconSize / 2, iconSize / 2],
                popupAnchor: [0, 0]
            });
            const esri = L.tileLayer(
            "https://wayback.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/WMTS/1.0.0/default028mm/MapServer/tile/49849/{z}/{y}/{x}",
            {
                attribution: "Esri, Maxar, Earthstar Geographics",
                maxNativeZoom: 18,
                maxZoom: 21,
                minZoom: 0,
                noWrap: false
            }
            );
            const esriLatest = L.tileLayer(
                "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
                {"attribution": "Esri", "detectRetina": false, "maxNativeZoom": 18, "maxZoom": 21, "minZoom": 0, "noWrap": false, "opacity": 1, "subdomains": "abc", "tms": false}
            )
            const govmap = L.tileLayer('https://cdnil.govmap.gov.il/xyz/heb/{z}/{x}/{y}.png', {
                maxZoom: 15,
                attribution: '© המרכז למיפוי ישראל www.govmap.gov.il',
            });
            var baseMaps = {
                "GovMap": govmap,
                "Esri latest": esriLatest,
                "Esri 2024-11-18": esri,
            };
            const map = L.map('map', {
                layers: [govmap, esriLatest, esri],
                center: [31.399114, 34.486365000000006],
                zoom: 15,
            });
            const Killed = L.featureGroup()
            const Kidnapped = L.featureGroup()
            const Areas = L.featureGroup()
            var allFeatures = [];  // Store all features for search
            
            // Fetch and parse the Hebrew HTML file to extract embedded GeoJSON
            fetch('https://oct7database.com/locations.html')
                .then(response => response.text())
                .then(html => {
                    // Find the line with "var geojsonData = " and extract the JSON object
                    const startMarker = 'var geojsonData = ';
                    const startIdx = html.indexOf(startMarker);
                    if (startIdx === -1) {
                        throw new Error('Could not find geojsonData declaration in locations.html');
                    }
                    const dataStart = startIdx + startMarker.length;
                    
                    // Find the matching closing brace by counting braces
                    let endIdx = -1;
                    let braceCount = 0;
                    let inString = false;
                    let escapeNext = false;
                    
                    // Parse through the JSON to find the true end
                    for (let i = dataStart; i < html.length; i++) {
                        const char = html[i];
                        
                        if (escapeNext) {
                            escapeNext = false;
                            continue;
                        }
                        
                        if (char === '\\') {
                            escapeNext = true;
                            continue;
                        }
                        
                        if (char === '"') {
                            inString = !inString;
                            continue;
                        }
                        
                        if (!inString) {
                            if (char === '{') {
                                braceCount++;
                            } else if (char === '}') {
                                braceCount--;
                                if (braceCount === 0) {
                                    endIdx = i + 1;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (endIdx === -1) {
                        throw new Error('Could not find end of geojsonData JSON object');
                    }
                    
                    const jsonString = html.substring(dataStart, endIdx);
                    const data = JSON.parse(jsonString);
                    
                    for (let feat of data.features) {
                        let event = feat['properties'].event
                        if (feat.geometry.type === 'Polygon') {
                            const coords = feat.geometry.coordinates[0].map(c => [c[1], c[0]])
                            const polygon = L.polygon(coords, {
                                fillColor: '#ff69b4',
                                weight: 2,
                                opacity: 1,
                                color: '#ff1493',
                                dashArray: '3',
                                fillOpacity: 0.3
                            }).addTo(Areas)
                            
                            // Get English name for polygon
                            var pidList = feat['properties']['pid'] ? feat['properties']['pid'].toString().split(',') : [];
                            var englishNames = pidList.map(function(pid) {
                                var trimmedPid = pid.trim();
                                if (nameMap[trimmedPid]) {
                                    return nameMap[trimmedPid].firstName + ' ' + nameMap[trimmedPid].lastName;
                                }
                                return '';
                            }).filter(function(name) { return name; });
                            
                            var displayName = englishNames.length > 0 ? englishNames.join(', ') : feat['properties'].name;
                            
                            // Get English place name from database using first PID
                            var firstPid = pidList.length > 0 ? pidList[0].trim() : '';
                            var englishPlace = (firstPid && nameMap[firstPid] && nameMap[firstPid].eventLocation) ? nameMap[firstPid].eventLocation : feat['properties'].place_name;
                            
                            var popupContent = englishPlace + '<br>' + displayName;
                            if (feat['properties'].link) {
                                popupContent += '<br><a href="' + feat['properties'].link + '" target="_blank">' + feat['properties'].link_text + '</a>';
                            }
                            polygon.bindPopup(popupContent);
                            allFeatures.push({
                                name: displayName,
                                place: englishPlace,
                                type: 'polygon',
                                layer: polygon,
                                feature: feat,
                                pid: feat['properties']['pid']
                            });
                        } else if (feat.geometry.type === 'Point') {
                            const lat = feat.geometry.coordinates[1]
                            const lng = feat.geometry.coordinates[0]
                            const coords = [lat, lng]
                            
                            // Get English name(s) from database - handle multiple PIDs
                            var pid = feat['properties']['pid'] ? feat['properties']['pid'].toString() : '';
                            var pidList = pid.split(',').map(p => p.trim());
                            var englishNames = pidList.map(function(singlePid) {
                                if (nameMap[singlePid]) {
                                    return nameMap[singlePid].firstName + ' ' + nameMap[singlePid].lastName;
                                }
                                return '';
                            }).filter(function(name) { return name; });
                            
                            var englishName = englishNames.length > 0 ? englishNames.join('<br>') : feat['properties'].name;
                            
                            // Get English place name from database using first PID
                            var firstPid = pidList.length > 0 ? pidList[0] : '';
                            var englishPlace = (firstPid && nameMap[firstPid] && nameMap[firstPid].eventLocation) ? nameMap[firstPid].eventLocation : feat['properties'].place_name;
                            
                            if (event === "killed") {
                                const marker = L.marker(coords, { icon: redIcon })
                                marker.bindTooltip(englishName, {
                                    permanent: true,
                                    direction: 'right',
                                    className: 'red-tooltip'
                                });
                                var popupContent = englishPlace;
                                if (feat['properties'].link) {
                                    popupContent += '<br><a href="' + feat['properties'].link + '" target="_blank">' + feat['properties'].link_text + '</a>';
                                }
                                marker.bindPopup(popupContent);
                                marker.addTo(Killed)
                                allFeatures.push({
                                    name: englishName,
                                    place: englishPlace,
                                    type: 'point',
                                    event: 'killed',
                                    layer: marker,
                                    feature: feat,
                                    pid: feat['properties']['pid']
                                });
                            } else if (event === "kidnapped") {
                                const marker = L.marker(coords, { icon: blueIcon })
                                marker.bindTooltip(englishName, {
                                    permanent: true,
                                    direction: 'left',
                                    className: 'blue-tooltip'
                                });
                                var popupContent = englishPlace;
                                if (feat['properties'].link) {
                                    popupContent += '<br><a href="' + feat['properties'].link + '" target="_blank">' + feat['properties'].link_text + '</a>';
                                }
                                marker.bindPopup(popupContent);
                                marker.addTo(Kidnapped)
                                allFeatures.push({
                                    name: englishName,
                                    place: englishPlace,
                                    type: 'point',
                                    event: 'kidnapped',
                                    layer: marker,
                                    feature: feat,
                                    pid: feat['properties']['pid']
                                });
                            } else {
                                console.log('Unknown event: ', event)
                            }
                        }
                    }
                    
                    // Function to focus on a specific feature by pid
                    window.focusOnPid = function(targetPid) {
                        var feature = allFeatures.find(function(f) {
                            if (!f.pid) return false;
                            var pids = f.pid.toString().split(',').map(function(p) { return p.trim(); });
                            return pids.includes(targetPid);
                        });
                        
                        if (feature) {
                            if (feature.type === 'polygon') {
                                var bounds = feature.layer.getBounds();
                                var center = bounds.getCenter();
                                map.setView(center, 15);
                                feature.layer.openPopup(center);
                            } else {
                                var latlng = feature.layer.getLatLng();
                                map.setView(latlng, 18);
                                feature.layer.openPopup();
                            }
                        }
                    };
                    
                    // Check for pid parameter in URL
                    var urlParams = new URLSearchParams(window.location.search);
                    var pid = urlParams.get('pid');
                    if (pid) {
                        document.getElementById('popup-message').style.display = 'none';
                        setTimeout(function() {
                            focusOnPid(pid);
                        }, 500);
                    }
                })
            
            var overlayMaps = {
                "Area": Areas,
                "Killed": Killed,
                "Kidnapped": Kidnapped
            };
            Areas.addTo(map)
            Killed.addTo(map)
            Kidnapped.addTo(map)
            var layerControl = L.control.layers(baseMaps, overlayMaps).addTo(map);
            document.getElementById('map').style.cursor = 'crosshair'
            map.on("contextmenu", function (event) {
                const coords = event.latlng.toString().slice(7, -1);
                navigator.clipboard.writeText(coords).then(() => {
                    alert("Coordinates copied to clipboard:\n" + coords);
                }).catch(err => {
                    console.error("Could not copy text: ", err);
                    window.prompt("Copy to clipboard: Ctrl+C, Enter", coords);
                });
            });
            
            // Search functionality
            const searchInput = document.getElementById('search-input');
            const searchResults = document.getElementById('search-results');
            
            function normalizeText(text) {
                if (!text) return '';
                return text
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f\u0591-\u05C7]/g, '')
                    .replace(/[׳״\u05F3\u05F4]/g, '')
                    .replace(/[^\u0590-\u05FF\u0600-\u06FF\w\s]/g, '')
                    .toLowerCase();
            }
            
            searchInput.addEventListener('input', function() {
                const query = this.value.trim();
                
                if (query.length < 2) {
                    searchResults.style.display = 'none';
                    searchResults.innerHTML = '';
                    return;
                }
                
                const normalizedQuery = normalizeText(query);
                
                const matches = allFeatures.filter(item => {
                    const normalizedName = normalizeText(item.name);
                    const normalizedPlace = normalizeText(item.place);
                    const nameMatch = normalizedName.includes(normalizedQuery);
                    const placeMatch = normalizedPlace.includes(normalizedQuery);
                    return nameMatch || placeMatch;
                });
                
                if (matches.length === 0) {
                    searchResults.style.display = 'none';
                    searchResults.innerHTML = '';
                    return;
                }
                
                searchResults.innerHTML = '';
                matches.slice(0, 20).forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'search-result-item';
                    div.textContent = item.name + ' - ' + item.place;
                    div.addEventListener('click', function() {
                        if (item.type === 'polygon') {
                            const bounds = item.layer.getBounds();
                            const center = bounds.getCenter();
                            map.setView(center, 15);
                            item.layer.openPopup(center);
                        } else {
                            const latlng = item.layer.getLatLng();
                            map.setView(latlng, 18);
                            item.layer.openPopup();
                        }
                        searchResults.style.display = 'none';
                        searchInput.value = '';
                    });
                    searchResults.appendChild(div);
                });
                
                searchResults.style.display = 'block';
            });
            
            document.addEventListener('click', function(e) {
                if (!searchResults.contains(e.target) && e.target !== searchInput) {
                    searchResults.style.display = 'none';
                }
            });
            
            } // end loadMap function
        </script>
    </div>
</body>
</html>
