<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="logo.png">
    <title>××–×¢×§×•×ª ××ª×—×™×œ×ª ×”××‘×¦×¢ â€” ××¤×ª ×—×•×</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <!-- leaflet.heat removed; using custom canvas heatmap for fixed color scale -->
    <style>
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, sans-serif; }
        #map { height: 100vh; width: 100vw; }

        #floating-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 20, 0.82);
            color: #fff;
            padding: 7px 16px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            z-index: 1000;
            direction: rtl;
            text-align: center;
            white-space: nowrap;
            backdrop-filter: blur(4px);
        }
        #floating-title .subtitle {
            display: block;
            font-size: 0.65em;
            color: #aac4ff;
            margin-top: 3px;
            font-weight: normal;
        }
        #floating-title .subtitle a { color: #7eb8ff; text-decoration: none; }
        #floating-title .subtitle a:hover { text-decoration: underline; }

        #search-container {
            position: absolute;
            top: 88px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: 230px;
            direction: rtl;
        }
        #search-input {
            width: 100%;
            padding: 7px 12px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.35);
            box-sizing: border-box;
            direction: rtl;
            background: rgba(10,10,20,0.82);
            color: #fff;
            backdrop-filter: blur(4px);
            outline: none;
        }
        #search-input::placeholder { color: #aaa; }
        #search-input:focus { box-shadow: 0 2px 12px rgba(100,180,255,0.4); }

        #autocomplete-list {
            background: rgba(15,15,30,0.95);
            border: 1px solid #334;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        .autocomplete-item {
            padding: 7px 12px;
            cursor: pointer;
            font-size: 0.95em;
            direction: rtl;
            color: #dde;
        }
        .autocomplete-item:hover, .autocomplete-item.selected {
            background: rgba(80,130,255,0.25);
            color: #fff;
        }

        .alarm-popup {
            direction: rtl;
            text-align: right;
            font-size: 0.95em;
            max-height: 260px;
            overflow-y: auto;
            min-width: 160px;
        }
        .alarm-popup h4 {
            margin: 0 0 6px 0;
            font-size: 1.05em;
            border-bottom: 1px solid #ccc;
            padding-bottom: 4px;
        }
        .alarm-popup .alarm-time { padding: 1px 0; color: #222; }

        .count-label { background: none !important; border: none !important; box-shadow: none !important; }
        .count-label-inner {
            font-size: 11px;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 0 3px #000, 0 0 7px #000, 0 0 2px #000;
            white-space: nowrap;
            pointer-events: none;
            line-height: 1;
        }

        .leaflet-control-attribution {
            background: transparent !important;
            font-size: 12px;
            color: #eee;
            text-shadow: 0 0 3px #000;
        }
        .leaflet-popup-content { margin: 10px 14px; }
    </style>
</head>
<body>
<div id="floating-title">
    ××–×¢×§×•×ª ××ª×—×™×œ×ª ×”××‘×¦×¢
    <div class="subtitle">
        ×××ª <a href="https://oct7database.com" target="_blank">oct7database.com</a> Â· × ×ª×•× ×™ ×¤×§×¢"×¨ ×“×¨×š
        <a href="https://www.tzevaadom.co.il/historical" target="_blank">×¦×‘×¢ ××“×•×</a>
    </div>
</div>

<div id="search-container">
    <input id="search-input" type="text" placeholder="×—×™×¤×•×© ×™×™×©×•×‘..." autocomplete="off" />
    <div id="autocomplete-list"></div>
</div>

<div id="map"></div>

<script>
    const GITHUB_RAW = 'https://raw.githubusercontent.com/yuval-harpaz/alarms/refs/heads/master/';
    const DATE_FROM = '2026-02-28';
    const DATE_TO   = '2027-02-28'; // change upper limit when alarms stop

    function parseDate(str) {
        if (!str) return null;
        return new Date(str.replace(' ', 'T'));
    }
    function formatTime(d) {
        return `${String(d.getDate()).padStart(2,'0')}/${String(d.getMonth()+1).padStart(2,'0')}/${d.getFullYear()} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
    }
    async function fetchCSV(f) {
        const r = await fetch(GITHUB_RAW + f);
        const text = await r.text();
        return new Promise(res => Papa.parse(text, { header:true, dynamicTyping:true, complete: d => res(d.data) }));
    }
    function buildPopupContent(loc, ts) {
        let h = `<div class="alarm-popup"><h4>${loc} â€” ${ts.length} ××–×¢×§×•×ª</h4>`;
        ts.forEach(t => { h += `<div class="alarm-time">ğŸ”´ ${t}</div>`; });
        return h + '</div>';
    }

    function haversine(lat1, lng1, lat2, lng2) {
        const R = 6371000;
        const dLat = (lat2-lat1)*Math.PI/180, dLng = (lng2-lng1)*Math.PI/180;
        const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLng/2)**2;
        return R*2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // Returns local maxima: points that are the highest-count within radiusMeters
    function findLocalMaxima(entries, radiusMeters, minCount) {
        return entries.filter(a => {
            if (a.count < minCount) return false;
            return entries.every(b => {
                if (b === a) return true;
                const dist = haversine(a.lat, a.lng, b.lat, b.lng);
                return dist > radiusMeters || a.count >= b.count;
            });
        });
    }

    async function initMap() {
        const [coord, alarms] = await Promise.all([fetchCSV('data/coord.csv'), fetchCSV('data/alarms.csv')]);

        if (new URLSearchParams(window.location.search).has('notitle'))
            document.getElementById('floating-title').style.display = 'none';

        const map = L.map('map').setView([31.5, 34.75], 8);
        L.tileLayer('https://cdnil.govmap.gov.il/xyz/heb/{z}/{x}/{y}.png', {
            attribution: 'Â© ×”××¨×›×– ×œ××™×¤×•×™ ×™×©×¨××œ www.govmap.gov.il', maxZoom: 18
        }).addTo(map);

        const coordMap = {};
        coord.forEach(c => {
            const lat = Number(c.lat), lng = Number(c.long);
            if (!isNaN(lat) && !isNaN(lng)) coordMap[c.loc] = [lat, lng];
        });

        const dayAlarms = alarms.filter(a => {
            const d = parseDate(a.time);
            if (!d || isNaN(d)) return false;
            const ds = d.toISOString().slice(0,10);
            return ds >= DATE_FROM && ds <= DATE_TO && a.threat === 0;
        });

        const locTimes = {};
        dayAlarms.forEach(a => {
            const city = a.cities;
            if (!city) return;
            if (!locTimes[city]) locTimes[city] = [];
            const d = parseDate(a.time);
            if (d) locTimes[city].push(d);
        });
        Object.keys(locTimes).forEach(loc => locTimes[loc].sort((a,b) => a-b));

        // Build locData array
        const locDataArr = [];
        const markerMap = {};

        Object.entries(locTimes).forEach(([loc, times]) => {
            const coords = coordMap[loc];
            if (!coords) { console.warn('No coords:', loc); return; }
            locDataArr.push({ loc, lat: coords[0], lng: coords[1], count: times.length });
        });

        const maxCount = Math.max(...locDataArr.map(d => d.count), 1);

        // Dark blue â†’ blue â†’ cyan â†’ green-yellow â†’ orange â†’ dark red
        // No white/cream stop so mid-range values stay visibly colored
        function countToColor(count) {
            const v = count / maxCount; // [0, 1]
            const stops = [
                [0.00, [ 20,  40, 160]],  // dark blue
                [0.20, [ 50, 130, 220]],  // medium blue
                [0.38, [ 60, 200, 210]],  // cyan
                [0.55, [100, 200,  80]],  // green
                [0.70, [255, 220,  50]],  // yellow
                [0.85, [240, 100,  20]],  // orange
                [1.00, [150,  15,  15]],  // dark red
            ];
            for (let i = 1; i < stops.length; i++) {
                const [t0, c0] = stops[i - 1];
                const [t1, c1] = stops[i];
                if (v <= t1) {
                    const t = (v - t0) / (t1 - t0);
                    const r = Math.round(c0[0] + t * (c1[0] - c0[0]));
                    const g = Math.round(c0[1] + t * (c1[1] - c0[1]));
                    const b = Math.round(c0[2] + t * (c1[2] - c0[2]));
                    return `rgb(${r},${g},${b})`;
                }
            }
            return `rgb(160,20,20)`;
        }

        // Draw colored circles sorted smallâ†’large so larger (redder) circles render on top
        const sortedEntries = Object.entries(locTimes).sort((a, b) => a[1].length - b[1].length);
        sortedEntries.forEach(([loc, times]) => {
            const coords = coordMap[loc];
            if (!coords) return;
            const count = times.length;
            const color = countToColor(count);
            const marker = L.circleMarker(coords, {
                radius: Math.max(Math.sqrt(count) * 2.5, 4),
                fillColor: color,
                color: 'none',
                weight: 0,
                fillOpacity: 0.8
            }).bindPopup(buildPopupContent(loc, times.map(formatTime)), { maxWidth: 280, maxHeight: 340 })
              .addTo(map);
            markerMap[loc] = marker;
        });

        // Southernmost point (min lat) â€” always labelled
        const southernmost = locDataArr.reduce((s, p) => p.lat < s.lat ? p : s, locDataArr[0]);

        // ---- Vertical Colorbar ----
        const colorbar = L.control({ position: 'bottomleft' });
        colorbar.onAdd = function() {
            const div = L.DomUtil.create('div');
            div.style.cssText = `
                background: rgba(10,10,20,0.82); border-radius: 8px; padding: 8px 10px;
                color: #fff; font-size: 11px; backdrop-filter: blur(4px);
                box-shadow: 0 2px 8px rgba(0,0,0,0.4); direction: rtl; text-align: right;
                display: flex; flex-direction: column; align-items: center; gap: 4px;
            `;
            const title = document.createElement('div');
            title.style.cssText = 'font-size:11px; color:#aac4ff; margin-bottom:2px; white-space:nowrap;';
            title.textContent = '××¡×¤×¨ ××–×¢×§×•×ª';

            const barH = 140, barW = 14;
            const bc = document.createElement('canvas');
            bc.width = barW; bc.height = barH;
            const bx = bc.getContext('2d');
            // Draw topâ†’bottom: max (red) at top, min (cyan) at bottom
            for (let i = 0; i < barH; i++) {
                const v = 1 - i / (barH - 1); // top = max
                bx.fillStyle = countToColor(Math.round(v * maxCount));
                bx.fillRect(0, i, barW, 1);
            }
            bc.style.cssText = 'border-radius:4px; display:block;';

            // Labels alongside bar: top=max, mid, bottom=0
            const wrapper = document.createElement('div');
            wrapper.style.cssText = 'display:flex; flex-direction:row; align-items:stretch; gap:4px;';
            const labelsDiv = document.createElement('div');
            labelsDiv.style.cssText = `display:flex; flex-direction:column; justify-content:space-between; height:${barH}px; font-size:11px; color:#ccc;`;
            labelsDiv.innerHTML = `<span>${maxCount}</span><span>${Math.round(maxCount/2)}</span><span>0</span>`;
            wrapper.appendChild(bc);
            wrapper.appendChild(labelsDiv);

            div.appendChild(title);
            div.appendChild(wrapper);
            return div;
        };
        colorbar.addTo(map);

        // ---- Labels at local maxima/minima, deduplicated by clustering ----
        let labelLayer = L.layerGroup().addTo(map);

        function getRadius(z) {
            return 30000 / Math.pow(2, z - 7);
        }
        function getMinCount(z) {
            if (z <= 7) return 10;
            if (z <= 9) return 5;
            if (z <= 11) return 2;
            return 1;
        }

        // Cluster nearby points with same count, return centroid of each cluster
        function clusterSameValue(points, radiusMeters) {
            const used = new Set();
            const centroids = [];
            points.forEach((a, i) => {
                if (used.has(i)) return;
                const group = [a];
                used.add(i);
                points.forEach((b, j) => {
                    if (used.has(j)) return;
                    if (b.count === a.count && haversine(a.lat, a.lng, b.lat, b.lng) < radiusMeters) {
                        group.push(b);
                        used.add(j);
                    }
                });
                const lat = group.reduce((s, p) => s + p.lat, 0) / group.length;
                const lng = group.reduce((s, p) => s + p.lng, 0) / group.length;
                centroids.push({ lat, lng, count: a.count });
            });
            return centroids;
        }

        function makeLabel(lat, lng, count) {
            const icon = L.divIcon({
                className: 'count-label',
                html: `<div class="count-label-inner">${count}</div>`,
                iconSize: [30, 14],
                iconAnchor: [15, 7]
            });
            return L.marker([lat, lng], { icon, interactive: false });
        }

        function redrawLabels() {
            labelLayer.clearLayers();
            const z = map.getZoom();
            const r = getRadius(z);
            const maxima = findLocalMaxima(locDataArr, r, getMinCount(z));
            const deduped = clusterSameValue(maxima, r * 0.6);

            // Always include southernmost point (forced label)
            const hasSouth = deduped.some(p =>
                haversine(p.lat, p.lng, southernmost.lat, southernmost.lng) < r * 0.5
            );
            if (!hasSouth && southernmost) {
                deduped.push({ lat: southernmost.lat, lng: southernmost.lng, count: southernmost.count });
            }

            deduped.forEach(({ lat, lng, count }) => {
                makeLabel(lat, lng, count).addTo(labelLayer);
            });
        }

        redrawLabels();
        map.on('zoomend', redrawLabels);

        // ---- Autocomplete search ----
        const allLocs = Object.keys(markerMap).sort();
        const searchInput = document.getElementById('search-input');
        const acList = document.getElementById('autocomplete-list');
        let selIdx = -1;

        function showSugg(q) {
            acList.innerHTML = ''; selIdx = -1;
            if (!q) return;
            allLocs.filter(l => l.includes(q)).slice(0,10).forEach(loc => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.textContent = loc;
                item.addEventListener('mousedown', e => { e.preventDefault(); selectLoc(loc); });
                acList.appendChild(item);
            });
        }
        function selectLoc(loc) {
            if (!loc) return;
            searchInput.value = loc;
            acList.innerHTML = '';
            const m = markerMap[loc];
            if (m) { map.setView(m.getLatLng(), 13); m.openPopup(); }
        }
        searchInput.addEventListener('input', () => showSugg(searchInput.value.trim()));
        searchInput.addEventListener('keydown', e => {
            const items = acList.querySelectorAll('.autocomplete-item');
            if (e.key === 'ArrowDown') { e.preventDefault(); selIdx = Math.min(selIdx+1, items.length-1); }
            else if (e.key === 'ArrowUp') { e.preventDefault(); selIdx = Math.max(selIdx-1, 0); }
            else if (e.key === 'Enter') { selectLoc(selIdx>=0 ? items[selIdx]?.textContent : items[0]?.textContent); return; }
            else if (e.key === 'Escape') { acList.innerHTML=''; return; }
            items.forEach((el,i) => el.classList.toggle('selected', i===selIdx));
        });
        searchInput.addEventListener('blur', () => setTimeout(() => acList.innerHTML='', 150));
        map.on('click', () => acList.innerHTML='');

        if (!locDataArr.length)
            L.popup().setLatLng([31.5,34.75]).setContent('×œ× × ××¦××• ××–×¢×§×•×ª.').openOn(map);
    }

    initMap();
</script>
</body>
</html>
